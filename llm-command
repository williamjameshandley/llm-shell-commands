#!/usr/bin/env python3
"""Convert natural language to shell commands using OpenAI API."""

import sys
import os
import json
import urllib.request
import urllib.error

def get_context() -> str:
    """Gather shell context for better command generation."""
    import subprocess
    import platform

    cwd = os.getcwd()
    shell = os.environ.get("SHELL", "unknown").split("/")[-1]
    user_type = "root" if os.geteuid() == 0 else "user"

    # Detect OS/distro
    os_info = platform.system()
    if os_info == "Linux":
        try:
            with open("/etc/os-release") as f:
                for line in f:
                    if line.startswith("PRETTY_NAME="):
                        os_info = line.split("=", 1)[1].strip().strip('"')
                        break
        except:
            pass
    elif os_info == "Darwin":
        os_info = "macOS"

    # Virtual environment
    venv = os.environ.get("VIRTUAL_ENV", "")
    venv_info = f"Virtual env: {os.path.basename(venv)}" if venv else ""

    # Git context
    git_info = ""
    try:
        branch = subprocess.check_output(
            ["git", "branch", "--show-current"],
            stderr=subprocess.DEVNULL, timeout=0.2
        ).decode().strip()
        if branch:
            git_info = f"Git branch: {branch}"
    except:
        pass

    # File listing with type indicators (using os.scandir for speed)
    files = []
    project_markers = {
        "package.json": "NodeJS", "requirements.txt": "Python",
        "pyproject.toml": "Python", "Cargo.toml": "Rust",
        "go.mod": "Go", "Makefile": "Make", "Dockerfile": "Docker"
    }
    project_types = set()

    try:
        with os.scandir('.') as it:
            entries = sorted(it, key=lambda e: e.name)
            for entry in entries:
                name = entry.name
                if name in project_markers:
                    project_types.add(project_markers[name])
                if entry.is_dir():
                    name += "/"
                elif entry.is_file() and os.access(entry.path, os.X_OK):
                    name += "*"
                if len(files) < 20:
                    files.append(name)
    except:
        pass

    file_list = '\n'.join(files)
    if len(files) == 20:
        file_list += "\n..."

    project_info = f"Project type: {', '.join(project_types)}" if project_types else ""

    # Build context string (skip empty lines)
    lines = [
        f"Directory: {cwd}",
        f"OS: {os_info}",
        f"Shell: {shell} ({user_type})",
        git_info,
        venv_info,
        project_info,
        f"Files:\n{file_list}" if file_list else ""
    ]
    return '\n'.join(line for line in lines if line)


def get_shell_command(description: str) -> str:
    """Send description to OpenAI and get back a shell command."""
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        return "# Error: OPENAI_API_KEY not set"

    context = get_context()

    prompt = f"""Convert this natural language description to a single shell command.
Return ONLY the command, no explanation, no markdown, no code blocks.

{context}

Description: {description}"""

    data = json.dumps({
        "model": "gpt-4o-mini",
        "messages": [
            {"role": "system", "content": "You are a shell command generator. Output only the command, nothing else."},
            {"role": "user", "content": prompt}
        ],
        "max_tokens": 256,
        "temperature": 0
    }).encode()

    req = urllib.request.Request(
        "https://api.openai.com/v1/chat/completions",
        data=data,
        headers={
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
    )

    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode())
            return result["choices"][0]["message"]["content"].strip()
    except urllib.error.HTTPError as e:
        return f"# Error: {e.code} {e.reason}"
    except Exception as e:
        return f"# Error: {e}"

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("# Usage: llm-command 'description'", file=sys.stderr)
        sys.exit(1)

    description = " ".join(sys.argv[1:])
    print(get_shell_command(description))
